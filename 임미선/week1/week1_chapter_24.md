## 🔖 개요
C, Java에 존재하는 `static` 키워드는 자바스크립트에 존재하지 않는다. 변수를 정적으로 관리해야할 때, 어떻게 `static` 을 구현할 수 있을지 찾아보다가 자바스크립트의 '클로저' 개념을 접하게 된 경험이 있었다.

자바스크립트 개념 중 난해하기로 유명한 '클로저'에 대해 알아보자.

## 🔖 렉시컬 스코프
### 📍 개념
자바스크립트는 렉시컬 스코프를 따르는 프로그래밍 언어이다.
다음 코드를 참고하면 알 수 있다.

```js
const x = 1;

function outerFunc() {
    const x = 10;

    function innerFunc() {
        console.log(x);
    }

    innerFunc();
}

outerFunc();
```

중첩함수 `innerFunc` 의 상위 스코프 = 외부 함수 `outerFunc` 의 스코프

그러므로 `innerFunc` 내부에서 자신을 포함하고 있는 외부 함수 `outerFunc` 의 변수 `x` 에 접근할 수 있다. 자바스크립트의 변수가 영향을 미칠 수 있는(접근할 수 있는 유효 범위) 영역을 잘 알고 있다면 당연한 개념이다. 이는 자바스크립트가 '렉시컬 스코프'를 따르는 프로그래밍 언어이기 때문이다.

💡 렉시컬 환경이란?
- 코득 어디서 실행되며 주변에 어떤 코드가 있는지를 말함
- 코드의 문맥은 렉시컬 환경으로 이루어짐 -> 실행 컨텍스트의 구현 배경

💡 실행 컨텍스트란?
- 스코프 = 실행 컨텍스트의 렉시컬 환경
- '렉시컬 환경'은 자신의 '외부 렉시컬 환경에 대한 참조'를 통해 상위 렉시컬 환경과 연결됨 -> '스코프 체인'

### 📍 렉시컬 스코프
자바스크립트는 함수를 어디서 '정의'했는지에 따라 상위 스코프를 결정한다. 따라서, 함수의 상위 스코프는 '함수의 정의'가 실행될 때 정적으로 결정된다. 이를 렉시컬 스코프(정적 스코프)라고 말한다.

```js
const x = 1;

function foo() {
    const x = 10;
    bar();
}

function bar() {
    console.log(x);
}

foo(); // output: ?
bar(); // output: ?
```

위 코드의 출력값은 각각 무엇일까?

함수의 상위 스코프는 함수 정의에 따라 결정되므로, `foo`, `bar` 두 함수의 상위 스코프는 전역이 된다. 그러므로 함수가 정의 될 때, 함수가 호출된 곳에 관계없이 언제나 자신이 기억하고 있는 전역 스코프를 상위 스코프로 사용한다. 따라서 두 출력값 모두 전역변수 `x` 의 값인 1을 출력한다.

💡 왜 출력값이 '10, 1'이 아닌가?
- 함수의 상위 스코프는 함수가 호출될 때가 아닌, 정의될 때라는 것을 명심해야 한다.
- 만약 함수 호출을 기준으로 상위 스코프가 결정된다면, `foo` 함수 내부의 `bar` 함수가 호출될 때 상위 스코프가 전역이 아닌 `foo` 함수가 되므로 10이 출력될 것이다.

### 📍 함수 객체의 내부 슬롯 [[Environment]]
위 내용을 정리해본다면 다음과 같다.

*함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경, 즉 상위 스코프(함수 정의가 위치하는 스코프가 바로 상위 스코프)를 기억해야 한다.*

함수가 정의될 때, 함수는 자신의 상위 스코프를 어떻게 기억하고 있을까? 이를 위해 함수는 자신의 내부 슬롯인 `[[Environment]]` 에 자신이 정의된 환경(상위 스코프의 참조)를 저장하게 된다. 

내부 슬롯 `[[Environment]]`에 저장된 상위 스코프의 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킨다. '전역 렉시컬 환경'이라 부를 수 있다.

렉시컬 스코프에서 참고한 코드를 다시 알아보자.
```js
const x = 1;

function foo() {
    const x = 10;

    // 상위 스코프는 함수 정의 위치에 따라 결정됨
    // 따라서, 함수 호출 위치와 상위 스코프는 관계가 없다.
    bar();
}

// bar 함수는 자신의 상위 스코프를 [[Environment]]에 저장하여 기억함
function bar() {
    console.log(x);
}

foo(); // output: ?
bar(); // output: ?
```

두 함수 모두 전역에서 함수를 정의하였다. 그러므로 전역 객체 `window` 의 메서드가 된다. 이때, 각 함수 내부 슬롯 `[[Environment]]` 에는 함수 정의가 평가된 시점(전역 코드 평가 시점)에 실행 중인 실행 컨텍스트의 렉시컬 환경인 '전역 렉시컬 환경의 참조'가 저장된다.

함수 호출 시, 함수 내부로 코드의 제어권이 이동한다.

함수 코드의 평가 순서는 다음과 같다.

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
3. 함수 환경 레코드 생성
4. this 바인딩
5. 외부 렉시컬 환경에 대한 참조 결정

## 🔖 클로저와 렉시컬 환경
### 📍 클로저란?
'클로저는 함수와 그 **함수가 선언된 렉시컬 환경**과의 조합이다.'

```js
const x = 1;

function outer() {
    const x = 10;
    
    const inner = function () { console.log(x); };

    return inner;
}

const innerFunc = outer();
innerFunc();
```

`outer` 함수 호출 시점에 중첩 함수 `inner` 를 반환하고 생명 주기가 마감된다. 따라서 실행 컨텍스트 스택에서 `outer` 함수의 실행 컨텍스트가 제거되고, `outer` 함수 내부의 변수 `x` 도 생명 주기를 마감한다. 

그렇다면, 더이상 `outer` 함수 내부의 변수 `x` 의 값인 10에 접근할 방법이 없는 걸까?

### 📍 생명 주기와 렉시컬 환경
`innerFunc` 호출 후 출력되는 값은 10이다. 분명히 스택에서도 제거되고 생명 주기도 마감된 변수 `x` 의 값을 어떻게 출력해낼 수 있었을까? 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있기 때문이다. 

예시에서는 `outer` 함수에서 `inner` 함수를 반환하여 `innerFunc`에 저장하므로 중첩 함수가 더 오래 유지된다. 외부 함수보다 더 오래 생존한 중첩 함수는 외부 함수의 생존 여부에 상관 없이 상위 스코프를 기억 한다. 중첩함수 `inner`를 통해 생명 주기가 종료된 `outer` 함수의 변수인 `x` 에 접근하여 10이라는 값을 얻어낼 수 있다.

이 때, 예시의 `inner` 함수와 같은 중첩 함수를 '클로저(Closure)'라고 부른다.

💡 생명 주기가 종료될 때 일어나는 일
- 예시의 `outer` 함수의 실행 컨텍스트가 제거될 때, `outer` 함수의 렉시컬 환경까지 소멸하지는 않음
- 따라서, 예시의 `inner` 함수의 내부 슬롯 `[[Environment]]` 에 의해 `outer` 함수의 렉시컬 환경을 참조하는 것이 가능함 -> 메모리 공간이 해제되지 않음

### 📍 모든 함수는 클로저인가?
자바스크립트의 모든 함수는 정의되는 동시에 전역을 상위 스코프로 가진다. 그렇다면, 자바스크립트의 모든 함수는 클로저일까?

클로저가 되기 위한 필수 요인으로는 '상위 스코프의 식별자를 참조하는 것'이다. 상위 스코프의 어떤 식별자도 참고하지 않는다면, 일반적으로 클로저라고 정의하지 않는다. 

💡 상위 스코프의 어떤 식별자도 참조하지 않는다면 굳이 상위 스코프를 기억해야 할까?
- 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않도록 함
- 메모리 자원을 아끼기 위함

### 📍 클로저가 되기 위하여
모든 함수가 클로저가 아니라는 것을 알게 되었다. 그럼 클로저가 되기 위한 조건은 어떤 것이 있을까?


클로저가 되기 위한 한정적인 경우는 다음과 같다.
1. 중첩 함수가 상위 스코프의 식별자를 참조하고 있음
2. 중첩 함수가 외부 함수보다 더 오래 유지되는 것

클로저에 의해 참조되는 상위 스코프의 변수를 '자유 변수'라고 부른다. 클로저는 '함수가 자유 변수에 대해 닫혀있다'라는 의미로, 자유 변수에 묶여 있는 함수라고 볼 수 있다.

## 🔖 클로저의 활용
### 📍 클로저의 목적
일반적으로, 전역 변수를 이용하여 상태 관리를 한다면 누구나 접근할 수 있어 의도치 않은 변경 사항과 함께 오류가 발생할 수도 있다.

클로저는 상태를 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

이전 상태를 유지하고, 특정 함수를 통해서만 접근할 수 있는 counter 함수를 만들어보자.

```js
const increase = (function () {
    let num = 0;

    // closure
    return function() {
        return ++num;
    };
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

`increase` 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저다. 

즉시 실행 함수는 호출된 이후 소멸되지만, 즉시 실행 함수가 반환한 클로저 함수는 `increase` 변수에 할당되어 생명 주기를 이어간다. 이를 통해 `num` 변수에 계속 접근할 수 있다. 

즉시 실행 함수에 의해 `num` 변수가 0으로 초기화되고, 이후에는 `increase`   변수를 통해 `num` 변수에 접근하여 1씩 증가시키는 것이 가능하다. (C나 자바의 static 변수와 비슷하다.) 따라서 특정 함수로만 접근 가능한 `private` 변수처럼 사용하고자 하는 상태를 관리하기 위해서 클로저를 사용할 수 있다. 

외부 상태 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에서 클로저는 적극적으로 사용된다. 클로저를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높일 수 있다.

```js
// 보조 함수 aux를 인자로 받는 고차함수
function makeCounter(aux) {
    let counter = 0;

    // closure
    return function () {
        counter = aux(counter);
        return counter;
    };
}

function increase(n) { return ++n; }
function decrease(n) { return --n; }

// 함수로 함수를 생성함 
// increaser, decreaser은 별개의 독립된 렉시컬 환경을 가짐
// counter 변수의 상태가 연동되지는 않음
const increaser = makeCounter(increase);
console.log(increaser()); // 1
console.log(increaser()); // 2

const decreaser = makeCounter(decrease);
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```

함수형 프로그래밍에 클로저를 적용함으로써 `counter` 변수를 증감시킬 수 있다. 

하지만, `increaser` 과 `decreaser` 은 별개의 독립된 렉시컬 환경을 가지므로 `counter` 변수의 상태가 연동되지 않는다.

다음과 같이 즉시 실행 함수를 통해 동일한 렉시컬 환경을 지닐 수 있는 클로저를 만들어 해결할 수 있다.

```js
const counter = (function () {
    let counter = 0;

    // closure
    return function(aux) {
        counter = aux(counter);
        return counter;
    };
}());

console.log(counter(increase)); // 1
console.log(counter(increase)); // 2
console.log(counter(decrease)); // 1
```

## 🔖 캡슐화와 정보 은닉
### 📍 캡슐화와 정보 은닉이란?
- 캡슐화 : 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 메서드를 하나로 묶는 것
- 정보 은닉 : 캡슐화를 통해 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하는 것 -> 정보 보호 및 낮은 결합도를 위함

### 📍 자바스크립트의 정보 은닉
자바스크립트는 다른 객체지향 프로그래밍 언어와 다르게 `private`, `public`, `protected` 와 같은 접근 제한자를 제공하지 않는다.

자바스크립트의 모든 프로퍼티와 메서드는 기본적으로 `public` 상태이고, 객체 내부 `private` 변수를 만들기 위해서는 다음과 같이 해야한다.

```js
function Person(name, age) {
    this.name = name; // public
    let _age = age; // private
}

Person.prototype.sayHi = function() {
    // not working, _age is undefined
    console.log(this.name, _age);
}
```

`_age` 변수는 `private` 변수이기에, `sayHi` 메서드에서 접근할 수 없다.

자바스크립트의 이러한 특징을 이용하여 `public`, `private` 변수를 생성할 수 있다. 앞서 설명한 내용과 같이 클로절르 이용한다면, `private` 변수에 접근할 수 있는 특정 함수를 만드는 것도 가능하다. 

하지만, 아쉽게도 자바스크립트의 정보 은닉은 완벽하지 않다. 클로저를 이용한 `private` 변수 접근은 즉시 실행 함수를 이용해야 하는데, 즉시 실행 함수의 특성상 최초 정의 시 한 번만 실행되기 때문에 하나가 아닌 여러개의 인스턴스를 만들 때 문제가 생긴다. 

이러한 자바스크립트의 `private` 이슈는 class 문법 내부에 `private` 변수를 선언할 수 있는 최신 브라우저 및 Node.js에 구현되어 있다. 변수명 선두에 '#'를 붙여 선언하는 방식이다. class 문법에 대해 공부하면 자세히 알 수 있다.