# 브라우저의 렌더링 과정
<br>

- 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 **요청 후 서버로부터 응답을 받음**
- 렌더링 엔진은 서버로부터 응답된 HTM과 CSS를 파싱하여 `DOM과 CSSOM`을 생성하고 이들을 결합하여 **렌더 트리를 생성**
- 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱 후, AST를 생성하고 바이트코드로 변환하여 실행.
- 이 때, 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합
- 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치 & 크기)를 계산하고 브라우저 화면에 HTML 요소를 페인팅함

<br>

## 요청과 응답
- 브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고 서버로부터 응답 받아 브라우저에 시각적으로 렌더링하는 것
- 서버에 요청하기 위해 브라우저는 주소창을 제공
- 주소창에 URL을 입력 후, 엔터 키를 누르면 URL 호스트 이름이 DNS 통해 컴퓨터가 해석할 수 있는 IP주소로 변환되고
- 이 IP 주소를 갖는 서버에 요청을 전송

```
// URI (Uniform Resource identifier)

https://www.mydomain.com:80/docs/search?category=javascript&lang=ko#intro
```
- **https** : Scheme(Protocol)
- **www.mydomain.com** : Host(Domain)
- *:80* : Port
- **/docs/search?** : Path
- **category=javascript&lang=ko** : Query(Query String)
- **#intro** : fragment

`URL`
- `https://www.mydomain.com:80/docs/search?`

`URN`
- `www.mydomain.com:80/docs/search?category=javascript&lang=ko#intro`

- 주소창에 스킴과 호스트를 포함한 요청을 전송하면 (ex. *https://www.naver.com*)
- naver.com 서버로 전송이 되고, 이 경우 리소스 요청 사항이 없으면 default는 index.html을 응답하게 설정되어 있음
- 다른 정적 파일을 서버에 요청하려면 브라우저의 주소창의 호스트 뒤 path에 경로를 명시해 주어야 함
- 파일 외에도 정적/동적 데이터를 요청할 수도 있음

<br>

## HTTP 1.1과 HTTP 2.0
<br>
- `HTTP`는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)

<br>

`HTTP/1.1`
- 커넥션 하나 당 하나의 요청과 응답만 처리 즉, 여러 개의 요청 한번에 전송 불가
- 즉, html, css, js에 대한 요청이 각각 전송 되고 응답 역시 각가 전송
- 리소스의 개수에 비례하여 응답 시간도 증가하는 단점
<br>

`HTTP/2`
- 커넥션 당 여러 개의 요청과 응답이 가능
- HTTP/1.1에 비해 페이지 로드 속도가 약 50% 정도 빠름

<br>

## HTML 파싱과 DOM 생성
- HTML 문서를 브라우저에 시각적 픽셀로 렌더링 하기 위해서는 HTML 문서를 브라우저가 이해할 수 있는 객체(DOM) 생성해야함
- `바이트` ➡️ `문자` ➡️ `토큰` ➡️ `노드` ➡️ `DOM`
- 바이트(2진수) 형태로 응답 받은 다음 응답 헤더에 담겨 전송되는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열 변환 
- 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해
- 각 토큰들을 객체로 변환하여 노드 생성 (문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드)
- 노드는 이후 DOM을 구성하는 기본 요소가 됨
- HTML 문서는 각 HTML 요소들의 집합으로 이루어지며 HTML 요소는 중첩 관계를 가짐 그리고 요소간의 중첩 관계에 의해 부자 관계가 형성됨
- 이러한 요소 간의 부자 관계를 반영하여 트리 자료구조로 구성 그리고 이것을 DOM이라고 부름

<br>

## CSS 파싱과 CSSOM 생성
- HTML을 순서대로 파싱하며 DOM을 생성해나가다가 CSS를 로드하는 link나 style 태그를 만나면 DOM 생성을 일시 중단
- 그리고 CSS 파일을 서버에 요청하여 로드한 후 HTML과 동일한 파싱 과정을 거치면서 CSSOM을 생성함

<br>

## 렌더 트리 생성
- 생성된 DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합
- 브라우저 화면에 렌더링 되는 노드만 구성됨
- meta나 script태그 CSS에 의해 비표시 되는 노드들은 포함하지 않음
- 완성된 렌더 트리는 각 HTML 요소의 레이아웃을 계산하는데 사용되고 픽셀 렌더링하는 페인팅 처리에 입력
- 즉, 리렌더링이 일어날때마다 새롭게 페인팅 처리가 필요하므로, 리렌더링이 빈번하게 발생하지 않도록 주의해야함

<br>

## 자바스크립트 파싱과 실행
- script 태그를 만나면, 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘기게 되는데
- 렌더링 엔진이 아닌 자바스크립트 엔진이 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환 한 후
- DOM, CSSOM과 같이 AST(추상적 구문 트리를 생성 후) 다시 렌더링 엔진으로 제어권을 넘기고 이어서 파싱 계속함
- `자바스크립트 소스코드` ➡️ `토큰` ➡️ `AST` ➡️ `바이트코드`
- 스크립트를 body 위쪽에 위치 시킬 경우, DOM을 파싱하다 자바스크립트 엔진에게 제어권을 넘기게 되므로
- 스크립트 내부에서 DOM API가 사용되는 경우 파싱되지 않은 DOM을 조작하는 오류가 발생할 수 있음
- 이러한 문제점을 해결하기 위한 방안으로는 body 요소의 가장 아래 단 즉, **닫는 body태그 위에 위치시키는 방법**과
- **async/defer 어트리뷰트를 사용**하여 비동기적으로 동시에 진행시키는 방법이 존재한다 

`async 어트리뷰트`
- 자바스크립트 파일의 로드와 HTML 파일의 로드가 동시 진행
- 다만, 자바스크립트의 파싱과 실행이 자바스크립트 파일 로드 후 진행되며, 이때 HTML 파싱은 중단
`defer 어트리뷰트`
- HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행
- 다만, 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, DOM 생성이 완료된 직후 진행

<br>

## 리플로우와 리페인트
- 자바스크립트에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM과 CSSOM이 변경됨
- 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 이 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 다시 렌더링
- 레이아웃 계산을 다시하는 것 ➡️ `리플로우` : 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징등 레이아웃 영향을 주는 변경 발생
- 재결합된 렌더 트리를 기반으로 다시 페인트 ➡️ `리페인트`
- 둘이 동시에 꼭 이루어지는 것이 아님 한 가지만 이루어 질 수 있다.

<br>

